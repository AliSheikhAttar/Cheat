I’m glad you understand the concept thoroughly! Let’s dive into your specific question: **What does the server sign in a JWT?** I’ll explain this in detail, step by step, and clarify what the payload and signature are exactly, along with how the signing routine works.

---

### What Does the Server Sign?

In a JSON Web Token (JWT), the server signs the **header and payload**. These two parts are combined and cryptographically signed to ensure their integrity—meaning no one can change them without the server detecting it. The signature is what makes this possible, acting like a seal of authenticity.

To explain this clearly, let’s break down the JWT structure and the signing process.

---

### The Structure of a JWT

A JWT has three parts, separated by dots (`.`):
1. **Header**
2. **Payload**
3. **Signature**

Each part is encoded in **Base64Url** format (a way to turn data into a string that’s safe for web use). Here’s what each part contains:

#### 1. Header
- The header is a JSON object that describes the token.
- It typically includes:
  - **`alg`**: The algorithm used to sign the token (e.g., `HS256` for HMAC SHA256 or `RS256` for RSA SHA256).
  - **`typ`**: The type of token, usually `"JWT"`.
- Example:
  ```json
  {
    "alg": "HS256",
    "typ": "JWT"
  }
  ```
- This JSON is **Base64Url-encoded** to become the first part of the JWT, like:  
  `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.

#### 2. Payload
- The payload is a JSON object that holds the **claims**—data about the user or the token.
- Common claims include:
  - **`sub`**: Subject (e.g., user ID, like `"123"`).
  - **`name`**: User’s name (e.g., `"John Doe"`).
  - **`exp`**: Expiration time (e.g., a Unix timestamp like `1698777600`).
  - Custom claims (e.g., `"role": "admin"`).
- Example:
  ```json
  {
    "sub": "123",
    "name": "John Doe",
    "exp": 1698777600
  }
  ```
- This is also **Base64Url-encoded**, becoming something like:  
  `eyJzdWIiOiIxMjMiLCJuYW1lIjoiSm9obiBEb2UiLCJleHAiOjE2OTg3Nzc2MDB9`.

#### 3. Signature
- The signature is a cryptographic code created by the server. It’s not a JSON object but a hash generated from the header and payload.
- I’ll explain how it’s made in the signing process below.

A complete JWT looks like this:  
`header.payload.signature`, for example:  
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJuYW1lIjoiSm9obiBEb2UiLCJleHAiOjE2OTg3Nzc2MDB9.someSignatureHere`.

---

### What Exactly is the Payload?

- The **payload** is the part of the JWT that carries the actual data (the claims). It’s where the server puts information about the user or the token’s purpose.
- **Key Characteristics**:
  - It’s **not encrypted**—it’s only Base64Url-encoded. Anyone can decode it and read the contents (e.g., using an online Base64 decoder).
  - Because it’s readable, you should **never put sensitive data** like passwords in the payload.
  - Its integrity (meaning it hasn’t been altered) is protected by the signature.
- Example: If the payload is `eyJzdWIiOiIxMjMifQ`, decoding it gives `{"sub": "123"}`.

In short, the payload is the **data container** of the JWT, holding information the server wants to share or verify later.

---

### What Exactly is the Signature?

- The **signature** is a cryptographic hash that ensures the header and payload haven’t been tampered with.
- **Key Characteristics**:
  - It’s generated by signing the **encoded header and encoded payload** together using a secret key or private key.
  - It proves the token came from a trusted source (the server) and hasn’t been altered.
  - When the server gets the token back, it checks the signature to confirm its validity.
- The signature isn’t human-readable data—it’s a string like `abc123def456` (simplified) after Base64Url encoding.

In short, the signature is the **security seal** that protects the header and payload.

---

### How the Signing Routine Works

Now, let’s walk through the process of how the server signs the JWT, focusing on what it signs and how.

#### Step 1: Create the Header and Payload
- The server builds the header and payload as JSON objects.
- Example:
  - Header: `{"alg": "HS256", "typ": "JWT"}`
  - Payload: `{"sub": "123", "exp": 1698777600}`

#### Step 2: Encode the Header and Payload
- Both are converted to Base64Url strings:
  - Encoded Header: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
  - Encoded Payload: `eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9`

#### Step 3: Combine Them
- The server concatenates the encoded header and payload with a dot (`.`):
  - `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9`
- **This is what the server signs**: the string `header.payload`.

#### Step 4: Sign the Combined String
- The server uses a cryptographic algorithm and a key to create the signature:
  - **Symmetric Signing (e.g., HS256)**:
    - Uses a **secret key** (e.g., `"my-secret-key"`).
    - Applies HMAC SHA256 to `header.payload` with the secret key.
  - **Asymmetric Signing (e.g., RS256)**:
    - Uses a **private key**.
    - Applies RSA SHA256 to `header.payload`.
- The result is a binary hash, which is then Base64Url-encoded to become the signature (e.g., `abc123def456`).

#### Step 5: Build the JWT
- The server combines all three parts:
  - `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9.abc123def456`

---

### What Does the Server Sign, in Detail?

- The server signs the **concatenated string of the encoded header and encoded payload**: `header.payload`.
- For example, if:
  - Encoded Header = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
  - Encoded Payload = `eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9`
- The server signs:  
  `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9`
- It does **not** sign the signature itself—the signature is the result of the signing process.

---

### How Does the Server Verify the Signature?

When the token comes back:
1. The server splits it into header, payload, and signature.
2. It takes the `header.payload` string and recomputes the signature using the same key:
   - Symmetric (HS256): Uses the secret key.
   - Asymmetric (RS256): Uses the public key to verify.
3. It compares the recomputed signature with the one in the token.
   - If they match, the token is valid, and the payload can be trusted.
   - If not, the token has been tampered with or is fake.

---

### Simple Example

Let’s say the server issues a token for user ID `123`:
- Header: `{"alg": "HS256", "typ": "JWT"}` → `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`
- Payload: `{"sub": "123", "exp": 1698777600}` → `eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9`
- Sign `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9` with secret key `"my-secret-key"`.
- Signature: `abc123def456` (simplified).
- JWT: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjMiLCJleHAiOjE2OTg3Nzc2MDB9.abc123def456`.

---

### Final Clarifications

- **What the Server Signs**: The `header.payload` string, ensuring both parts stay unchanged.
- **Payload**: The data (claims) in the token, readable but protected by the signature.
- **Signature**: The cryptographic proof that the header and payload are authentic and untampered.
